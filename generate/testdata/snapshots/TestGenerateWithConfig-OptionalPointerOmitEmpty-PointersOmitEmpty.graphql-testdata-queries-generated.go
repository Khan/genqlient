// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package queries

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
	"github.com/Khan/genqlient/internal/testutil"
)

// PointersOmitEmptyQueryOtherUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A User is a user!
type PointersOmitEmptyQueryOtherUser struct {
	// id is the user's ID.
	//
	// It is stable, unique, and opaque, like all good IDs.
	Id string `json:"id"`
}

// GetId returns PointersOmitEmptyQueryOtherUser.Id, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryOtherUser) GetId() string { return v.Id }

// PointersOmitEmptyQueryResponse is returned by PointersOmitEmptyQuery on success.
type PointersOmitEmptyQueryResponse struct {
	// user looks up a user by some stuff.
	//
	// See UserQueryInput for what stuff is supported.
	// If query is null, returns the current user.
	User *PointersOmitEmptyQueryUser `json:"user"`
	// user looks up a user by some stuff.
	//
	// See UserQueryInput for what stuff is supported.
	// If query is null, returns the current user.
	OtherUser    *PointersOmitEmptyQueryOtherUser `json:"otherUser"`
	MaybeConvert *time.Time                       `json:"-"`
}

// GetUser returns PointersOmitEmptyQueryResponse.User, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryResponse) GetUser() *PointersOmitEmptyQueryUser { return v.User }

// GetOtherUser returns PointersOmitEmptyQueryResponse.OtherUser, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryResponse) GetOtherUser() *PointersOmitEmptyQueryOtherUser {
	return v.OtherUser
}

// GetMaybeConvert returns PointersOmitEmptyQueryResponse.MaybeConvert, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryResponse) GetMaybeConvert() *time.Time { return v.MaybeConvert }

func (v *PointersOmitEmptyQueryResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PointersOmitEmptyQueryResponse
		MaybeConvert json.RawMessage `json:"maybeConvert"`
		graphql.NoUnmarshalJSON
	}
	firstPass.PointersOmitEmptyQueryResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.MaybeConvert
		src := firstPass.MaybeConvert
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = testutil.UnmarshalDate(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal PointersOmitEmptyQueryResponse.MaybeConvert: %w", err)
			}
		}
	}
	return nil
}

type __premarshalPointersOmitEmptyQueryResponse struct {
	User *PointersOmitEmptyQueryUser `json:"user"`

	OtherUser *PointersOmitEmptyQueryOtherUser `json:"otherUser"`

	MaybeConvert json.RawMessage `json:"maybeConvert"`
}

func (v *PointersOmitEmptyQueryResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PointersOmitEmptyQueryResponse) __premarshalJSON() (*__premarshalPointersOmitEmptyQueryResponse, error) {
	var retval __premarshalPointersOmitEmptyQueryResponse

	retval.User = v.User
	retval.OtherUser = v.OtherUser
	{

		dst := &retval.MaybeConvert
		src := v.MaybeConvert
		if src != nil {
			var err error
			*dst, err = testutil.MarshalDate(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal PointersOmitEmptyQueryResponse.MaybeConvert: %w", err)
			}
		}
	}
	return &retval, nil
}

// PointersOmitEmptyQueryUser includes the requested fields of the GraphQL type User.
// The GraphQL type's documentation follows.
//
// A User is a user!
type PointersOmitEmptyQueryUser struct {
	// id is the user's ID.
	//
	// It is stable, unique, and opaque, like all good IDs.
	Id          *string  `json:"id"`
	Roles       []Role   `json:"roles"`
	Name        *string  `json:"name"`
	Emails      []string `json:"emails"`
	EmailsNoPtr []string `json:"emailsNoPtr"`
}

// GetId returns PointersOmitEmptyQueryUser.Id, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryUser) GetId() *string { return v.Id }

// GetRoles returns PointersOmitEmptyQueryUser.Roles, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryUser) GetRoles() []Role { return v.Roles }

// GetName returns PointersOmitEmptyQueryUser.Name, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryUser) GetName() *string { return v.Name }

// GetEmails returns PointersOmitEmptyQueryUser.Emails, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryUser) GetEmails() []string { return v.Emails }

// GetEmailsNoPtr returns PointersOmitEmptyQueryUser.EmailsNoPtr, and is useful for accessing the field via an interface.
func (v *PointersOmitEmptyQueryUser) GetEmailsNoPtr() []string { return v.EmailsNoPtr }

// Role is a type a user may have.
type Role string

const (
	// What is a student?
	//
	// A student is primarily a person enrolled in a school or other educational institution and who is under learning with goals of acquiring knowledge, developing professions and achieving employment at desired field. In the broader sense, a student is anyone who applies themselves to the intensive intellectual engagement with some matter necessary to master it as part of some practical affair in which such mastery is basic or decisive.
	//
	// (from [Wikipedia](https://en.wikipedia.org/wiki/Student))
	RoleStudent Role = "STUDENT"
	// Teacher is a teacher, who teaches the students.
	RoleTeacher Role = "TEACHER"
)

var AllRole = []Role{
	RoleStudent,
	RoleTeacher,
}

// UserQueryInput is the argument to Query.users.
//
// Ideally this would support anything and everything!
// Or maybe ideally it wouldn't.
// Really I'm just talking to make this documentation longer.
type UserQueryInput struct {
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
	// id looks the user up by ID.  It's a great way to look up users.
	Id         string            `json:"id,omitempty"`
	Role       *Role             `json:"role,omitempty"`
	Names      []*string         `json:"names,omitempty"`
	HasPokemon *testutil.Pokemon `json:"hasPokemon,omitempty"`
	Birthdate  *time.Time        `json:"-"`
}

// GetEmail returns UserQueryInput.Email, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetEmail() *string { return v.Email }

// GetName returns UserQueryInput.Name, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetName() *string { return v.Name }

// GetId returns UserQueryInput.Id, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetId() string { return v.Id }

// GetRole returns UserQueryInput.Role, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetRole() *Role { return v.Role }

// GetNames returns UserQueryInput.Names, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetNames() []*string { return v.Names }

// GetHasPokemon returns UserQueryInput.HasPokemon, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetHasPokemon() *testutil.Pokemon { return v.HasPokemon }

// GetBirthdate returns UserQueryInput.Birthdate, and is useful for accessing the field via an interface.
func (v *UserQueryInput) GetBirthdate() *time.Time { return v.Birthdate }

func (v *UserQueryInput) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*UserQueryInput
		Birthdate json.RawMessage `json:"birthdate"`
		graphql.NoUnmarshalJSON
	}
	firstPass.UserQueryInput = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Birthdate
		src := firstPass.Birthdate
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = testutil.UnmarshalDate(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal UserQueryInput.Birthdate: %w", err)
			}
		}
	}
	return nil
}

type __premarshalUserQueryInput struct {
	Email *string `json:"email,omitempty"`

	Name *string `json:"name,omitempty"`

	Id string `json:"id,omitempty"`

	Role *Role `json:"role,omitempty"`

	Names []*string `json:"names,omitempty"`

	HasPokemon *testutil.Pokemon `json:"hasPokemon,omitempty"`

	Birthdate json.RawMessage `json:"birthdate,omitempty"`
}

func (v *UserQueryInput) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *UserQueryInput) __premarshalJSON() (*__premarshalUserQueryInput, error) {
	var retval __premarshalUserQueryInput

	retval.Email = v.Email
	retval.Name = v.Name
	retval.Id = v.Id
	retval.Role = v.Role
	retval.Names = v.Names
	retval.HasPokemon = v.HasPokemon
	{

		dst := &retval.Birthdate
		src := v.Birthdate
		if src != nil {
			var err error
			*dst, err = testutil.MarshalDate(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal UserQueryInput.Birthdate: %w", err)
			}
		}
	}
	return &retval, nil
}

// __PointersOmitEmptyQueryInput is used internally by genqlient
type __PointersOmitEmptyQueryInput struct {
	Query *UserQueryInput `json:"query,omitempty"`
	Dt    *time.Time      `json:"-"`
	Tz    string          `json:"tz,omitempty"`
}

// GetQuery returns __PointersOmitEmptyQueryInput.Query, and is useful for accessing the field via an interface.
func (v *__PointersOmitEmptyQueryInput) GetQuery() *UserQueryInput { return v.Query }

// GetDt returns __PointersOmitEmptyQueryInput.Dt, and is useful for accessing the field via an interface.
func (v *__PointersOmitEmptyQueryInput) GetDt() *time.Time { return v.Dt }

// GetTz returns __PointersOmitEmptyQueryInput.Tz, and is useful for accessing the field via an interface.
func (v *__PointersOmitEmptyQueryInput) GetTz() string { return v.Tz }

func (v *__PointersOmitEmptyQueryInput) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*__PointersOmitEmptyQueryInput
		Dt json.RawMessage `json:"dt"`
		graphql.NoUnmarshalJSON
	}
	firstPass.__PointersOmitEmptyQueryInput = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Dt
		src := firstPass.Dt
		if len(src) != 0 && string(src) != "null" {
			*dst = new(time.Time)
			err = testutil.UnmarshalDate(
				src, *dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal __PointersOmitEmptyQueryInput.Dt: %w", err)
			}
		}
	}
	return nil
}

type __premarshal__PointersOmitEmptyQueryInput struct {
	Query *UserQueryInput `json:"query,omitempty"`

	Dt json.RawMessage `json:"dt,omitempty"`

	Tz string `json:"tz,omitempty"`
}

func (v *__PointersOmitEmptyQueryInput) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *__PointersOmitEmptyQueryInput) __premarshalJSON() (*__premarshal__PointersOmitEmptyQueryInput, error) {
	var retval __premarshal__PointersOmitEmptyQueryInput

	retval.Query = v.Query
	{

		dst := &retval.Dt
		src := v.Dt
		if src != nil {
			var err error
			*dst, err = testutil.MarshalDate(
				src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal __PointersOmitEmptyQueryInput.Dt: %w", err)
			}
		}
	}
	retval.Tz = v.Tz
	return &retval, nil
}

// The query executed by PointersOmitEmptyQuery.
const PointersOmitEmptyQuery_Operation = `
query PointersOmitEmptyQuery ($query: UserQueryInput, $dt: DateTime, $tz: String) {
	user(query: $query) {
		id
		roles
		name
		emails
		emailsNoPtr: emails
	}
	otherUser: user(query: $query) {
		id
	}
	maybeConvert(dt: $dt, tz: $tz)
}
`

func PointersOmitEmptyQuery(
	ctx_ context.Context,
	client_ graphql.Client,
	query *UserQueryInput,
	dt *time.Time,
	tz string,
) (data_ *PointersOmitEmptyQueryResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "PointersOmitEmptyQuery",
		Query:  PointersOmitEmptyQuery_Operation,
		Variables: &__PointersOmitEmptyQueryInput{
			Query: query,
			Dt:    dt,
			Tz:    tz,
		},
	}

	data_ = &PointersOmitEmptyQueryResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

